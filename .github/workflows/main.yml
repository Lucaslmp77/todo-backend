name: CI/CD

on:
  push:
    branches: [ main ]

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Authenticate to Google Cloud
        # Use v2 - geralmente mais recente e recomendado
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}
          # scopes: 'cloud-platform' # Adicione escopos se necessário para a Service Account

      - name: Set up Google Cloud CLI
        # Use v2
        uses: google-github-actions/setup-gcloud@v2
        with:
           version: 'latest' # Garante a versão mais recente do gcloud
           # Remove 'kubectl' daqui se for instalar via apt-get/componentes manualmente
           install_components: 'kubectl' # Instala o kubectl usando o gcloud components

      - name: Configure gcloud and Kubectl
        run: |
          # Configure o projeto
          gcloud config set project ${{ secrets.PROJECT_ID }}

          # *** CORREÇÃO AQUI: Use REGION us-central1 ***
          gcloud config set compute/region us-central1

          # *** CORREÇÃO AQUI: Use --region us-central1 ***
          gcloud container clusters get-credentials ${{ secrets.GKE_CLUSTER }} --region us-central1

          # Se você usa `install_components: 'kubectl'` no step anterior, as linhas abaixo são redundantes:
          # sudo apt-get update -y
          # sudo apt-get install -y kubectl
          # gcloud components install kubectl # Já incluído no setup-gcloud@v2

          # Se necessário, instale o plugin de autenticação GKE se o step anterior não o fizer automaticamente:
          # gcloud components install gke-gcloud-auth-plugin --quiet

          # Verificar versões para depuração (Opcional)
          echo "--- Versions ---"
          gcloud --version
          kubectl version --client
          docker --version
          echo "----------------"


      - name: Build and Push Docker Image to Docker Hub
        run: |
          set -x # Ativar debug de comandos

          DOCKER_USERNAME="${{ secrets.DOCKER_USERNAME }}"

          # Define a versão da imagem (usando o hash completo do commit)
          IMAGE_TAG="${{ github.sha }}"

          # Nome completo da imagem no Docker Hub
          FULL_IMAGE_NAME="$DOCKER_USERNAME/backend" # Não inclua a tag aqui

          # Nome da imagem com a tag SHA
          IMAGE_WITH_SHA_TAG="${FULL_IMAGE_NAME}:${IMAGE_TAG}"
          # Nome da imagem com a tag latest
          IMAGE_WITH_LATEST_TAG="${FULL_IMAGE_NAME}:latest"


          echo "Debug: Full Image Name: '${FULL_IMAGE_NAME}'"
          echo "Debug: Image with SHA Tag: '${IMAGE_WITH_SHA_TAG}'"
          echo "Debug: Image with Latest Tag: '${IMAGE_WITH_LATEST_TAG}'"

          echo "Building image..."
          # Build com a tag 'latest' localmente, que será usada para taguear as outras versões
          docker build -t "${FULL_IMAGE_NAME}:latest" .

          # Marca a imagem com a tag SHA
          echo "Tagging image '${FULL_IMAGE_NAME}:latest' as '${IMAGE_WITH_SHA_TAG}'"
          docker tag "${FULL_IMAGE_NAME}:latest" "${IMAGE_WITH_SHA_TAG}"

          # Autentica com Docker Hub
          echo "Logging in to Docker Hub..."
          echo ${{ secrets.DOCKER_PASSWORD }} | docker login -u "$DOCKER_USERNAME" --password-stdin

          # Envia as imagens
          echo "Pushing image '${IMAGE_WITH_LATEST_TAG}'..."
          docker push "${IMAGE_WITH_LATEST_TAG}"
          echo "Pushing image '${IMAGE_WITH_SHA_TAG}'..."
          docker push "${IMAGE_WITH_SHA_TAG}"

          set +x # Desativar debug

      - name: Deploy to Kubernetes
        run: |
          set -x # Ativar debug de comandos

          # Use o namespace CONSISTENTE com seus arquivos YAML e cluster
          NAMESPACE=approval

          # Caminhos dos arquivos de configuração (ajuste se estiverem em subpastas como k8s/)
          DEPLOYMENT_FILE=backend-deployment.yaml
          SERVICE_FILE=backend-service.yaml

          # Nome completo da imagem construída com a tag SHA
          DOCKER_USERNAME="${{ secrets.DOCKER_USERNAME }}"
          IMAGE_WITH_SHA_TAG="$DOCKER_USERNAME/backend:${{ github.sha }}"

          # Nome do deployment e container, DO SEU YAML (confirmados anteriormente)
          DEPLOYMENT_NAME="backend-deployment"
          CONTAINER_NAME="backend"
          kubectl apply -f postgres-secrets.yaml -n "${NAMESPACE}"
          kubectl apply -f postgres-service.yaml -n "${NAMESPACE}"
          kubectl apply -f postgres-deployment.yaml -n "${NAMESPACE}"

          echo "Debug: Image Name for Deployment: '${IMAGE_WITH_SHA_TAG}'"
          echo "Deploying image ${IMAGE_WITH_SHA_TAG} to namespace ${NAMESPACE}"

          # Aplica o Service
          echo "Applying Service from ${SERVICE_FILE}..."
          kubectl apply -f "${SERVICE_FILE}" -n "${NAMESPACE}"

          # Aplica o Deployment (cria se não existir, ou atualiza a definição geral se mudar algo no YAML)
          echo "Applying Deployment from ${DEPLOYMENT_FILE}..."
          kubectl apply -f "${DEPLOYMENT_FILE}" -n "${NAMESPACE}"

          # Aguardar um pouco para o Deployment ser criado/atualizado antes de tentar setar a imagem
          sleep 10

          # Atualiza a imagem do container 'backend' dentro do deployment 'backend-deployment'
          echo "Updating image for deployment '${DEPLOYMENT_NAME}', container '${CONTAINER_NAME}' to '${IMAGE_WITH_SHA_TAG}'"
          kubectl set image deployment/"${DEPLOYMENT_NAME}" "${CONTAINER_NAME}"="${IMAGE_WITH_SHA_TAG}" -n "${NAMESPACE}"
          echo "Image update command issued."

          # Aguardar o rollout para verificar se a atualização da imagem foi bem sucedida
          echo "Waiting for rollout of deployment '${DEPLOYMENT_NAME}' to complete..."
          kubectl rollout status deployment/"${DEPLOYMENT_NAME}" -n "${NAMESPACE}" --timeout=5m
          echo "Rollout status checked."

          set +x # Desativar debug
